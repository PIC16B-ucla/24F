{
  "hash": "d760f22b30879be5ff3c71d8fd84e11d",
  "result": {
    "markdown": "---\ntitle: \"Homework 4: Heat Diffusion\"\ndate: \"2024-02-07\"\nimage: good.png\ncategories: [Homework]\ndraft: false\n---\n\nIn this blog assignment, you will conduct a simulation of two-dimensional heat diffusion in various ways.\n\nIn the lecture notes, we represented the steps to simulate one-dimensional heat diffusion as a sequence of matrix-vector multiplications. Let's expand it to two dimensions.\n\nIn two-dimensions, the heat equation reads:\n$$\\frac{\\partial f(x, t)}{\\partial t} = \\frac{\\partial^2 f}{\\partial x^2 } + \\frac{\\partial^2 f}{\\partial y^2 }\\;.$$\nUsing a similar discretization scheme as in the one-dimensional case, let's put:\n$$\nx_i = i \\Delta x,\\;\\; y_j = j \\Delta y,\\;\\; t_k = k \\Delta t,\n$$\nfor $i = 0, \\cdots, N-1$; $j = 0, \\cdots, N-1$; and $k = 0, 1, 2 \\cdots$. \n\nWhen we define $u_{i, j}^k = f(x_i, y_j, t_k)$, the update equation in discrete time can be represented as:\n$$\nu_{i, j}^{k+1} \\approx u_{i, j}^k + \\epsilon \\left(u_{i+1, j}^k  + u_{i-1, j}^k + u_{i, j+1}^k + u_{i, j-1}^k - 4 u_{i, j}^k\\right), \n$$\nwhere $\\epsilon$ is a small parameter. \nThe boundary condition can be constructed to allow heat to escape, as follows: \n$$\nu_{-1, j}^k = u_{N, j}^k = u_{i, -1}^k = u_{i, N}^k = 0.\n$$\nWe are not explicitly allocating space for $u_{-1, j}^k$, $u_{N, j}^k$, $u_{i, -1}^k$, or $u_{i, N}^k$. (Note: the index -1 here does not mean the last index as in Python indexing; it just means $x = - \\Delta x$ or $y = - \\Delta y$.)\n\n\nFor this homework, we will use:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nN = 101\nepsilon = 0.2\n```\n:::\n\n\nand we will use a similar initial condition as in the 1D case: putting 1 unit of heat at the midpoint.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nfrom matplotlib import pyplot as plt\n# construct initial condition: 1 unit of heat at midpoint. \nu0 = np.zeros((N, N))\nu0[int(N/2), int(N/2)] = 1.0\nplt.imshow(u0)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n<matplotlib.image.AxesImage at 0x1399ddbd0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-2.png){width=435 height=414}\n:::\n:::\n\n\n## 1. With matrix multiplication\nAs in the linear algebra lecture, let's use matrix-vector multiplication to simulate the heat diffusion in the 2D space.\nThe vector here is created by `flatten`ing the current solution $u_{i, j}^k$. Each iteration of the update is given by: (EDITED 2/20)\n```python\ndef advance_time_matvecmul(A, u, epsilon):\n    \"\"\"Advances the simulation by one timestep, via matrix-vector multiplication\n    Args:\n        A: The 2d finite difference matrix, N^2 x N^2. \n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    N = u.shape[0]\n    u = u + epsilon * (A @ u.flatten()).reshape((N, N))\n    return u\n```\nThat is, we view $u_{i, j}^k$ as the element with index $N \\times i + j$ in a vector of length $N^2$.\nPut this function in the file `heat_equation.py`.\nLet's follow the indexing used in the update equation above. The matrix `A` has the size of $N^2 \\times N^2$, without all-zero rows or all-zero columns. The corresponding matrix `A` is given by:\n```python\nn = N * N\ndiagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]\ndiagonals[1][(N-1)::N] = 0\ndiagonals[2][(N-1)::N] = 0\nA = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)\n```\nDefine a function `get_A(N)`, that takes the value `N` as the argument and returns the corresponding matrix `A` in `heat_equation.py`. \n\nLet's run the simulation with `get_A()` and `advance_time_matvecmul()` we defined. \nRun the code for 2700 iterations.\nHow long does it take?\nVisualize the diffusion of heat every 300 iterations. Since our grading is PDF-based, please use a 3x3 grid of 2D heatmaps or contour plots. You are welcome to create an animation later. Since we want to compare computation time between multiple methods, we should not count the time needed for visualization. Thus, we need to store the intermediate solutions in a separate array.\n\n<!--\nAt the end of the run, your solution should be symmetric and invariant under 90-degree rotations. It should look like:\n\n![](good.png)\n\nbut not like:\n\n![](bad.png)\n-->\n\n\n## 2. Sparse matrix in JAX\n\nIn fact, the performance of Part 1 is supposed to be excruciatingly slow. While we can use the underlying optimized matrix multiplication routine from BLAS (basic linear algebra subprograms), it is not particularly effective here, as the matrix `A` has less than $5N^2$ nonzero elements out of $N^4$ elements.\nMost of operations are wasted for computing zeros. Let's use the data structure that exploits a lot of zeros in the matrix `A`: sparse matrix data structures. The JAX package holds an experimental sparse matrix support.\nWe can use the batched coordinate ([`BCOO`](https://jax.readthedocs.io/en/latest/jax.experimental.sparse.html)) format to only use $O(N^2)$ space for the matrix, and only take $O(N^2)$ time for each update.[^1]\n\n[^1]: There are several sparse matrix representations for more general sparsity patterns, including CSR (Compressed Sparse Row), CSC (Compressed Sparse Column), COO (COOrdinate format), etc. They are available in `scipy`. \n\nLet's define the function `get_sparse_A(N)`, a function that returns `A_sp_matrix`, the matrix `A` in a sparse format, given `N` in `heat_equation.py`. Repeat Part 1 using `get_A_sparse()` and the `jit`-ed version of `advance_time_matvecmul`.\n\nRun the code for 2700 iterations.\nHow long does it take?\nVisualize the diffusion of heat every 300 iterations. \n\n## 3. Direct operation with `numpy`\nThe matrix-vector multiplication approach is useful, particularly in other PDE problems like Poisson equations, where the matrix equation has to be solved.\nHowever, with the heat equation, it is not something absolutely necessary in terms of computation. It could be simpler with vectorized array operations like `np.roll()`.\nWrite a function `advance_time_numpy(u, epsilon)` that advances the solution by one timestep in the file `heat_equation.py`. You may pad zeroes to the input array to form an $(N + 2) \\times (N + 2)$ array internally, \nbut the argument and the returned solution should still be $N \\times N$. \n\nRun the code for 2700 iterations.\nHow long does it take? \nVisualize the diffusion of heat every 300 iterations. \n\n## 4. With `jax`\nNow, let's use `jax` to do the similar using just-in-time compilation, defining a function `advance_time_jax(u, epsilon)` in `heat_equation.py` -- without using (sparse) matrix multiplication routines. It will be simple to use the function `advance_time_numpy()` as the starting point.\nDon't forget to `jit`!\nKeep in mind that `jax` does not support index assignment.\n\nRun the code for 2700 iterations.\nHow long does it take? It is a good idea to first run it for a small number of iterations to get it compiled, and then run it again with the full 2700 iterations to get high performance with precompiled code. It is possible to make it faster than Part 3, excluding the compilation time.\nVisualize the diffusion of heat every 300 iterations. \n\n## 5. Comparison\nCompare the implementation and performances of the four methods. Which one is the fastest? Which one was easier for you to write?\n\n\n# Specifications\nPlease remember that you must meet all specifications in order to receive credit on the first submission!\n\n## Format\n0. As always, please submit the PDF printout of your blog post with URL visible to the \"pdf\" window, and any code you wrote (other than the `heat_equation module`) to the `files` window, including the files `index.ipynb` and `index.py`. Please submit the file `heat_equation.py` to the autograder.\n\n## Coding Problem\n\n1. The functions work correctly -- checked by autograder.\n2. The contents of all the functions are displayed in the blog post with `inspect.getsource()`.\n\n### Part 1\n3. The visualized solution appears correct -- the solution should be symmetric, invariant under a 90-degree rotation.\n4. The time elapsed is shown, excluding time used for visualization.\n\n### Part 2-4\n5. The function is implemented as required.\n6. The time elapsed is shown, excluding time used for visualization.\n7. Part 2 should be at least 10x faster than Part 1. \n8. Part 3 should be at least 100x faster than Part 1. \n9. Part 4 should be about twice as fast as Part 3.\n10. The visualized solution appears correct.\n\n### Part 5\n11. The four implementations and their performances are compared.\n\n## Style and Documentation\n12. Code throughout is written using minimal repetition and clean style.\n13. Docstrings are helpful. \n14. Please make sure to include useful comments and detailed explanations for each of your code blocks.\n15. Any repeated operations should be enclosed in functions.\n\n## Writing\n16. The blog post is written in tutorial format, in engaging and clear English. Grammar and spelling errors are acceptable within reason.\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}